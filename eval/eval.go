package eval

/* 
 eval provides a single function, Eval, that "evaluates" its argument. See documentation for Eval for more details
 author: Sriram Srinivasan (sriram@malhar.net)
*/

import (
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

var (
	builtinPkgs map[string]string
)

func init() {
	builtinPkgs = make(map[string]string)
	pkgs := []string{
		"hash/adler32", "crypto/aes", "encoding/ascii85", "encoding/asn1",
		"go/ast", "sync/atomic", "encoding/base32", "encoding/base64",
		"math/big", "encoding/binary", "bufio", "go/build",
		"bytes", "compress/bzip2", "net/http/cgi", "runtime/cgo",
		"crypto/cipher", "math/cmplx", "image/color", "hash/crc32",
		"hash/crc64", "crypto", "encoding/csv", "runtime/debug",
		"crypto/des", "go/doc", "image/draw", "database/sql/driver",
		"crypto/dsa", "debug/dwarf", "crypto/ecdsa", "debug/elf",
		"crypto/elliptic", "errors", "os/exec", "expvar",
		"net/http/fcgi", "path/filepath", "flag", "compress/flate",
		"fmt", "hash/fnv", "image/gif", "encoding/gob",
		"debug/gosym", "compress/gzip", "hash", "container/heap",
		"encoding/hex", "crypto/hmac", "html", "net/http",
		"net/http/httputil", "image", "io", "io/ioutil",
		"image/jpeg", "encoding/json", "net/rpc/jsonrpc", "container/list",
		"log", "compress/lzw", "debug/macho", "net/mail",
		"math", "crypto/md5", "mime", "mime/multipart",
		"net", "os", "text/template/parse", "go/parser",
		"path", "debug/pe", "encoding/pem", "crypto/x509/pkix",
		"image/png", "net/http/pprof", "go/printer",
		"math/rand", "crypto/rc4", "reflect",
		"regexp", "container/ring", "net/rpc", "crypto/rsa",
		"runtime", "text/scanner", "crypto/sha1",
		"crypto/sha256", "crypto/sha512", "os/signal", "net/smtp",
		"sort", "database/sql", "strconv", "strings",
		"crypto/subtle", "index/suffixarray", "sync", "regexp/syntax",
		"syscall", "log/syslog", "text/tabwriter", "archive/tar",
		"text/template", "net/textproto", "time",
		"crypto/tls", "go/token", "unicode", "unsafe",
		"net/url", "os/user", "unicode/utf16", "unicode/utf8",
		"crypto/x509", "encoding/xml", "archive/zip", "compress/zlib",
	}

	for _, pkg := range pkgs {
		builtinPkgs[pkg[strings.LastIndex(pkg, "/")+1:]] = pkg
	}
}

// Eval "evaluates" a multi-line bit of go code by compiling and running it. It
// returns either a non-blank compiler error, or the combined stdout and stderr output
// generated by the evaluated code.  
// Eval is designed to help interactive exploreation, and so provides
// the conveniences illustrated in the example below
//   Eval(`
//         p "Eval demo"
//         type A struct {
//               S string
//               V int
//         }
//         a := A{S: "The answer is", V: 42}
//         p "a = ", a
//         fmt.Printf("%s: %d\n", a.S, a.V)
// `)
// This should return: 
//     Eval demo
//     a =  {The answer is 42}
//     The answer is: 42
// 
// 1. A line of the form "p XXX" is translated to _p(XXX), where _p is an embedded function (see buildMain)
// 2. There is no need to import standard go packages. They are inferred
//    and imported automatically. (e.g. "fmt" in the code above)
// 3. The code is wrapped inside a main package and a main function. 
//    Explicit import statements, type declarations and func declarations
//    remain at the top-level (outside the main function)
// 

func Eval(code string) (out string, err string) {
	defer func() { // error recovery
		if e := recover(); e != nil {
			out = ""
			err = fmt.Sprintf("1:%v", e)
		}
	}()
	// No additional wrapping if it has a package declaration already
	if ok, _ := regexp.MatchString("^ *package ", code); ok {
		out, err = run(code)
		return out, err
	}

	code = expandAliases(code)
	pkgsToImport := inferPackages(code)
	topLevel, nonTopLevel := partition(code)
	return buildAndExec(topLevel, nonTopLevel, pkgsToImport)
}

func expandAliases(code string) string {
	// Expand "p foo(), 2*3"   to __p(foo(), 2*3)
	r := regexp.MustCompile(`(?m)^\s*p +(.*)$`)
	code = string(r.ReplaceAll([]byte(code), []byte("__p($1)")))

	// Expand "t foo(), 2*3"   to __t(foo(), 2*3)
	r = regexp.MustCompile(`(?m)^\s*t +(.*)$`)
	return string(r.ReplaceAll([]byte(code), []byte("__t($1)")))
}

// split code into topLevel and non-topLevel chunks. non-topLevel chunks belong inside
// a main function, and topLevel chunks refer to type, func and import declarations
// The return topLevel and nonTopLevel strings also contain embedded line numbers 
// of the form "//line :xxx" that is understood by the go compiler to refer to the
// correct line number in the original source.
func partition(code string) (topLevel string, nonTopLevel string) {
	isTopLevel := false
	brackOpenAt := 0    // Line num of open bracket, if code ends with unclosed brackets
	closingCh := " "[0] // One of ' ', '}', ')'.  ' ' means we are not looking for a closing bracketing ch at the beginning of line
	// Note: Using " "[0] instead of ' ' to avoid mixing runes and bytes.

	// Simplistic strategy for paren/brack matching: We only look for open parens/brackets at end of line, and the corresponding
	// closing parens/brackets at beginning of line. These are counted to account for nesting as well.
	brackCount := 0
	for i, line := range strings.Split(code, "\n") {
		l := strings.TrimSpace(line)
		if len(l) > 0 {
			// check line beginning. Is it closing a paren
			if l[0] == closingCh {
				brackCount--
				if brackCount == 0 {
					closingCh = ' '
					brackOpenAt = 0
				}
			} else if brackCount == 0 {
				// look for func/type/import decls 
				isTopLevel = strings.HasPrefix(l, "func ") || strings.HasPrefix(l, "type ") || strings.HasPrefix(l, "import ")
			}
			// Is there a dangling '{' or '(' at EOL?.
			switch l[len(l)-1] {
			case '{':
				closingCh = "}"[0]
				if brackCount == 0 {
					brackOpenAt = i
				}
				brackCount++
			case '(':
				closingCh = ")"[0]
				if brackCount == 0 {
					brackOpenAt = i
				}
				brackCount++
			}

			line = fmt.Sprintf("//line :%d\n%s\n", i+1, line) // prepend line numbers for the go compiler
		}
		if isTopLevel {
			topLevel += line
		} else {
			nonTopLevel += line
		}
	}
	if brackCount > 0 {
		panic(fmt.Sprintf("%d: Bracket or paren not closed. %d", brackOpenAt, brackCount))
	}
	return
}

var pkgPat = regexp.MustCompile(`(?m)\b[a-z]\w+\.`)

func inferPackages(code string) (pkgsToImport map[string]bool) {
	pkgsToImport = make(map[string]bool) // used as a set
	pkgs := pkgPat.FindAllString(code, -1)
	for _, pkg := range pkgs {
		pkg = pkg[:len(pkg)-1] // remove trailing '.'
		if importPkg, ok := builtinPkgs[pkg]; ok {
			pkgsToImport[importPkg] = true
		}
	}
	return pkgsToImport
}

func buildAndExec(topLevel string, nonTopLevel string, pkgsToImport map[string]bool) (out string, err string) {
	src := buildMain(topLevel, nonTopLevel, pkgsToImport)
	out, err = run(src)
	if err != "" {
		if repairImports(err, pkgsToImport) {
			src = buildMain(topLevel, nonTopLevel, pkgsToImport)
			out, err = run(src)
		}
	}
	return out, err
}

func repairImports(err string, pkgsToImport map[string]bool) (dupsDetected bool) {
	// Look for compile errors of the form
	// "test.go:10: xxx redeclared as imported package name"
	// and remove 'xxx' from pkgsToImport
	dupsDetected = false
	var pkg string
	r := regexp.MustCompile(`(?m)(\w+) redeclared as imported package name|imported and not used: "(\w+)"`)
	for _, match := range r.FindAllStringSubmatch(err, -1) {
		// Either $1 or $2 will have name of pkg name that's been imported
		if match[1] != "" {
			pkg = match[1]
		} else if match[2] != "" {
			pkg = match[2]
		}
		if pkgsToImport[pkg] {
			// Was the duplicate import our mistake, due to an incorrect guess? If so ... 
			delete(pkgsToImport, pkg)
			dupsDetected = true
		}
	}
	return dupsDetected
}

func run(src string) (output string, err string) {
	tmpfile := save(src)
	cmd := exec.Command("go", "run", tmpfile)
	out, e := cmd.CombinedOutput()
	if e != nil {
		err = ""
		errPat := regexp.MustCompile(`^:(\d+)\[.*\]:(.*)$`)
		for _, e := range strings.Split(string(out), "\n") {
			if strings.HasPrefix(e, "# command-line-arguments") {
				continue
			}
			err += errPat.ReplaceAllString(e, ":$1:$2\n")
		}
		return "", err
	} else {
		return string(out), ""
	}
	return "", ""
}

func save(src string) (tmpfile string) {
	tmpfile = tempDir() + string(os.PathSeparator) + "gore_eval.go"
	fh, err := os.OpenFile(tmpfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic("Unable to open file: '" + tmpfile + "': " + err.Error())
	}
	fh.WriteString(src)
	fh.Close()
	return tmpfile
}

func buildMain(topLevel string, nonTopLevel string, pkgsToImport map[string]bool) string {
	imports := ""
	delete(pkgsToImport, "fmt") // Explicitly importing fmt in the template below
	for k, _ := range pkgsToImport {
		imports += `import "` + k + "\"\n"
	}
	template := `
package main
import "fmt"
%s
%s
func main() {
     %s
}

func __p(values ...interface{}){
	for _, v := range values {
             fmt.Printf(%s, v)
	}
}
func __t(values ...interface{}){
	for _, v := range values {
             fmt.Printf(%s, v)
	}
}
`
	valueFmt := `"%+v\n"` // Embedding %v into template expands it prematurely!
	typeFmt := `"%T\n"`
	return fmt.Sprintf(template, imports, topLevel, nonTopLevel, valueFmt, typeFmt)
}

func tempDir() string {
	dir := os.Getenv("TMPDIR")
	if dir == "" {
		dir = "/tmp"
	}
	return dir
}
